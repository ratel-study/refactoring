# Gwen
리팩터링 스터디

---

# 1. 이해하기 힘든 이름

- 어떤 역할을 하는지, 어떻게 쓰이는지 직관적이어야 한다.
    - 함수 선언 변경하기
    - 변수, 필드 이름 바꾸기
    

### 함수 선언 변경하기

코드를 보지 않아도 이름만 보고도 이해할 수 있어야 한다.

how? 함수에 주석을 작성한 다음, 주석을 함수 이름으로 만들어 본다.

### 변수 이름 바꾸기

### 필드 이름 바꾸기

Record 자료 구조 : 특정 데이터와 관련있는 필드를 묶어 놓은 자료 구조

# 2. 중복 코드

- 중복 코드의 단점
    - 비슷한지, 완전히 동일한 코드인지 주의 깊게 봐야한다.
    - 코드를 변경할 때, 동일한 모든 곳의 코드를 변경해야 한다.
    

how?

- 함수 추출
- 코드가 비슷하게 생겼지만 완전히 같지는 않은 경우, 코드 분리
- 여러 하위 클래스에 동일한 코드가 있다면, 메소드 올리기

코드 정리

함수에서 사용할 변수를 상단에 미리 정의x

→ 해당 변수를 사용하는 코드 바로 위에 선언

두 메소드가 비슷한 절차를 따르고 있다면, 템플릿 메소드 패턴 적용 고려

# 3. 긴 함수

how?

- 대부분 함수 추출하기로 해결
- 함수로 분리하면서 해당 함수로 전달해야 할 매개변수가 많아진다면
    - 임시 변수를 질의 함수로 바꾸기
    - 매개변수 객체 만들기
        - 해당 데이터간의 관계를 보다 명시적으로 나타낼 수 있다.
        - 함수에 전달할 매개변수 개수를 줄이기
    - 객체 통째로 넘기기
        - 어떤 한 레코드에서 구할수 있는 여러 값들을 함수에 전달하는 경우, 해당 매개변수를 레코드 하나로 교체할 수 있다.
        - 매개변수 목록을 줄일 수 있다.
        - 의존성은 고려해야함
        - 메소드의 위치가 적절하지 않을 수 있다.
- 함수를 명령으로 바꾸기
    - 함수를 독립적인 객체인, Command로 만들어 사용할 수 있다
        - 부가적인 기능으로 undo 기능을 만들 수 있다.
        - 더 복잡한 기능을 구현하는데 필요한 여러 메소드를 추가할 수 있다.
        - 상속이나 템플릿을 활용할 수 있다.
        - 복잡한 메소드를 여러 메소드나 필드를 활용해 쪼갤 수 있다.
- 조건문 분해하기
    - 기술적으로는 함수 추출하기와 동일한 리팩토링이지만 의도만 다를 뿐
    - ex) 모두 메서드로 만들고 삼항연산자로 변경
- 반복문 쪼개기
    - 기능에 이상이 없을지 등 여러 작업을 모두 고려해야함
    - 성능 문제를 야기할 수 있지만, 리팩토링은 성능 최적화와 별개의 작업. 리팩토링을 마친 이후 성능 최적화를 시도할 수 있다.
- 조건문을 다형성으로 바꾸기
    - 같은 조건으로 여러개의 switch문이 있다면, 각기 다른 클래스를 만들어 제거할 수 있다.
    - 모든 조건문을 다형성으로 바꿔야 하는 것은 아니다.

# 4. 긴 매개변수 목록

- 함수에 매개변수가 많은 수록 함수의 역할을 이해하기 어려워진다.
    - 그 함수는 한가지 일을 하고 있는게 맞는가?
    - 불필요한 매개변수는 없는가?
    - 하나의 레코드로 뭉칠 수 있는 매개변수 목록은 없는가?

- 매개변수를 질의 함수로 바꾸기
- 플래그 인수 제거하기
    - 플래그는 함수에 매개변수로 전달해서 함수 내부의 로직을 분기하는데 사용한다.
    - 플래그를 사용한 함수는 차이를 파악하기 어렵다.
        - bookConcert(customer, false), bookConcert(customer, true)
        - bookConcert(customer), premiumBookConcert(customer)
- 여러 함수를 클래스로 묶기
    - 클래스 내부로 메소드를 옮기고 데이터를 필드로 만들면 메소드에 전달해야 하는 매개변수 목록도 줄일 수 있다.
